#                 FX -- Functional Experiments in Lua                #

##                           Introduction                           ##

Although Lua can be used for functional programming, it lacks the
usual toolset of functions that one needs for functional programming.
Some of those functions are easily implemented in Lua, others should
be implemented in C to avoid unnecessary performance loss. This
library contains a small core implemented in C that aims to make
functional (and in particular point-free or tacit) programming in Lua
easier. It mimics features from Clojure, and the [Ramda][1] Javascript
library, and will at some point be retitled to "Functional Extensions"
once it leaves experimental status.

  [1]: http://ramdajs.com/


##                             Concepts                             ##

###                Currying and Partial Application                ###

Currying is the process of transforming a function call taking n
arguments (e.g. `f( 1, 2, 3 )` into n function calls taking one
argument each (`f( 1 )( 2 )( 3 )`). Every function call except the
last just returns a new function that is a partially applied version
of the original one (i.e. the arguments provided so far are saved for
the final call). Currying and partial application are useful tools for
functional programming, because they provide an easy and syntactically
pleasing way to create specialized functions from generic ones.


###                     Lua For-Loop Iterators                     ###

Most functional programming languages provide a lazy data structure
that generates data on demand, and thus avoids unnecessary memory
allocation. In Lua the `for`-loop iterators fill this need. They also
provide a generic interface for iterating data structures.

A `for`-loop iterator in Lua consists of up to three values: an
*iterator* function (or something callable, `f`), a *state* (`s`), and
an *initial value* or *loop control value* (`var`). Those three values
are also called an *iterator tuple* (or *iterator triplet*, even tough
the last two values are optional). `for`-loop iterators are typically
generated by a function call to an *iterator factory* (e.g. `pairs`).

Ideally, the `var` value is the only thing that changes during an
iteration, because then you can easily save the state of the iteration
and resume or redo it later. We call such an iterator triplet an
*immutable iterator* (because neither `f` nor `s` contain information
that is modified during iteration). Examples of generators that return
immutable iterators are `pairs` and `ipairs`.

*Mutable iterators* on the other hand modify information stored in
`f`'s upvalues, or in `s`, or even in the local variables of a
coroutine during iteration. Saving the current state of the iteration
becomes more difficult or even impossible. Examples are the iterators
returned by `io.lines` and `string.gmatch`.

As a middle-ground, a *cloneable iterator* concentrates all mutable
state in the `s` value (and `var` of course), and provides a way to
create a copy of `s`. The cloneable iterators in this module identify
themselves by setting the `__metatable` field of the state's metatable
to the string `"cloneable"`, and provide a `__call` metamethod to do
the actual state copying.

The ["Programming in Lua" book][2] distinguishes between *stateful*
and *stateless iterators*. The text implies that you don't need to
allocate memory when using stateless iterators, because the iterator
doesn't need iteration-specific upvalues (so it can be pre-allocated
and re-used), and the state value is passed to the factory from the
outside. This property is so rare that the concept of a stateless
iterator as described is not very useful. In the majority of cases you
need at least some upvalues or a new table to hold the iteration
state.

As an alternative to cloneable iterators you could return a modified
copy of the current state as the loop control value (`var`) on each
iteration. The [LuaFun][3] library does this. The advantage is that
all your iterators are immutable by default (LuaFun calls this purely
functional). Downsides are that the loop control variable contains
internal iteration state that the user isn't interested in (and
shouldn't touch), and that you might need to allocate memory on every
iteration if the state is a little more complex.  Obviously, this
technique doesn't help reducing memory allocations even if the
resulting iterator technically might be stateless.

Some generators in this module take an iterator as input and return a
modified iterator. The properties of the modified iterator obviously
depend on the properties of the input iterator, so those types of
iterators are called *dependent iterators*. The dependent iterators in
this module expect the cloneable input iterators to follow the usual
protocol that is outlined above.

  [2]: http://www.lua.org/pil/7.3.html
  [3]: https://github.com/rtsisyk/luafun


###                           Transducers                          ###

[*Transducers*][4] (or *reducing function transformers*) are built on
the realization that `reduce` is the ultimate iteration function. It
works by calling a *reducing function* on each tuple/value during an
iteration, returning an updated state value that is then passed to the
next call of the reducing function and finally returned as the result
of `reduce`:

```lua
function aReducer( state, ... )
  -- ...
  return newState
end
```

A transducer is a function that takes a reducing function and returns
another reducing function:

```lua
function aTransducer( aReducer )
  return function( state, ... )
    if p( ... ) then
      return aReducer( state, f( ... ) )  -- pass (modified) data
    else
      return state  -- don't forward data
    end
  end
end
```

The new reducing function may forward the current iteration variables
(modified or as-is) to the old reducing function, or it may instead
return the state from the last call, basically ignoring the current
iteration step. The big advantage is that transducers only deal with
other reducing functions, and only the very last reducing function in
the chain needs to be aware of the contents of the state or where the
data is supposed to go. Thus, you can compose complex transformations
that are independent of the final output, and without intermediate
temporary copies of the iterated data structure.

  [4]: http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming


##                             Reference                            ##

*   `fx.has( s ) ==> f`

    The `has` function takes a string of comma-separated field names
    and returns a function that checks for the existence of those
    fields in the given argument. The function returns `true` if all
    required fields are non-`nil`, and `false` otherwise. If a field
    name starts with a double underscore `"__"`, the field is looked
    up in the metatable instead. Some metamethods are assumed to be
    defined for certain Lua types (e.g. `__call` for functions).

    Field names may consist only of letters, digits, and `_`.
    Everything else (not just comma) is considered a field separator.
    This is an extended and optimized version of a [proposal][5] on
    the lua-l mailing list.

    Example:
    ```lua
    assert( fx.has"__index,__newindex"( t ) )
    -- raises an error if `t` is either not a table or doesn't
    -- have a metatable with __index and __newindex defined.
    assert( fx.has"__add,__sub"( n ) )
    -- works for numbers and objects with __add and __sub.
    ```


*   `fx.curry( n, f ) ==> f2`

    `fx.curry` creates a function that supports partial application
    simply by calling it with less than the expected number of
    arguments `n`. The result of such a partial application supports
    partial application the same way until all required arguments have
    been supplied, at which point the original function `f` is called
    with all collected argument values. The special `fx._` value can
    be used as an argument to reserve the slot for a later call.
    Reserved slots are filled from left to right, and the original
    function will not be called as long as there are placeholder
    values in the argument list.

    Example:
    ```lua
    local f = fx.curry( 3, print )
    -- the following expressions are all equivalent:
    f( 1, 2, 3 )
    f( 1 )( 2 )( 3 )
    f( 1, 2 )( 3 )
    f( 1 )( 2, 3 )
    f( fx._, 2 )( 1, 3 )
    f( fx._, 2 )( fx._, 3 )( 1 )
    ```


*   `fx._`

    `fx._` is a placeholder value that can be used to reserve a slot
    in the argument list during partial application, or to terminate a
    reduction early.


*   `fx.compose( f, ... ) ==> f2`

    `fx.compose` does function composition on a variable number of
    given functions. The resulting closure calls the functions from
    right to left, passing the return values as arguments to the next
    function.

    Example:
    ```lua
    local f = fx.compose( g, h, i )
    -- is equivalent to:
    local function f( ... )
      return g( h( i( ... ) ) )
    end
    ```


*   `fx.map( fun, f [, s [, var]] ) ==> f2, s2, var2`

    `fx.map( fun, t, ... ) ==> t2`

    `fx.map( fun ) ==> x`

    `fx.map` applies a function to all elements generated by an
    iterator or contained in a table(-like object), returning a new
    iterator or table, respectively. If the second argument is a
    function, `f`, `s`, and `var` are used as an iterator triplet,
    and another iterator is returned that generates the tuples
    `var_1, fun( var_1, ..., var_n )`.

    If `f`/`t` is not a function but defines a `__map@fx` metamethod
    in its metatable, `fx.map` delegates to this metamethod, passing
    all given arguments.

    Otherwise the second argument is treated as a sequence(-like
    object). It is indexed using consecutive integers starting from
    `1` until a `nil` value is encountered. A new table that contains
    the results of `fun( v, ... )` is returned, where `v` is the value
    from `t` and `...` are the extra arguments from the `fx.map` call.

    If `fx.map` is called *without* a second argument, it returns a
    transducer which applies `fun` to all values except the `state`
    parameter during `reduce`ing.

    The `fx.map` function is automatically curried with one expected
    argument. This isn't very useful unless you use the placeholder
    value `fx._`:

    ```lua
    fx.map( g )       --> returns transducer
    fx.map( g, fx._ ) --> returns partially applied `fx.map` that
                      --  awaits the `f` or `t` argument.
    ```

    The returned transducer `x` is stateless unless `fun` maintains
    its own state, and returned iterators have the same properties
    as the input iterators.


*   `fx.filter( pred, f [, s [, var]] ) ==> f2, s2, var2`

    `fx.filter( pred, t, ... ) ==> t2`

    `fx.filter( pred ) ==> x`

    The `fx.filter` function calls a predicate to decide whether to
    pass a value/tuple through or filter it out. If the second
    argument is a function, `f`, `s`, and `var` are evaluated as an
    iterator triplet, and the result of `pred( var_1, ..., var_n )`
    determines whether the generated tuple `var_1, ..., var_n` is
    also generated by the result iterator triplet, or filtered out
    entirely.

    If the second argument is not a function, it is assumed to be a
    sequence(-like object) that is indexed by consecutive integers
    starting from `1` and ending at the first `nil` value. The
    predicate is applied to each value passing extra arguments from
    the `fx.filter` call: `pred( v, ... )`. The result is a table that
    contains only those elements `v` for which the predicate returned
    a `true`-ish value.

    If `fx.filter` is called *without* a second argument, it returns a
    transducer which filters during `reduce`ing. The predicate is
    applied to all generated values except the `state` parameter in
    that case.

    The `fx.filter` function is automatically curried with one
    expected argument. This isn't very useful unless you use the
    placeholder value `fx._`:

    ```lua
    fx.filter( p )       --> returns transducer
    fx.filter( p, fx._ ) --> returns partially applied `fx.filter`
                         --  that awaits the `f` or `t` argument.
    ```

    The returned transducer `x` is stateless unless `pred` maintains
    its own state, and returned iterators have the same properties
    as the input iterators.


*   `fx.take( np, f [, s [, var]] ) ==> f2, s2, var2`

    `fx.take( np, t, ... ) ==> t2`

    `fx.take( np ) ==> x`

    `fx.take` takes tuples/values from the beginning of an iteration
    or a sequence(-like) object. The first parameter `np` may either
    be a positive integer in which case this number of tuples/elements
    is selected, or a predicate in which case all tuples/elements are
    taken as long as the predicate evaluates to a `true`ish value.

    If the second argument is a function, `f`, `s`, and `var` are
    evaluated as an iterator triplet, and the resulting iterator
    generates tuples as long as the predicate returns `true`, or the
    given number of tuples hasn't been reached. Iteration stops after
    that.

    Otherwise the second argument is assumed to be a sequence(-like
    object) which is indexed using consecutive integers starting from
    `1` and ending at the first `nil` value unless the iterations is
    stopped prematurely because of the `np` argument. If `np` is a
    predicate, it is called with the value from the sequence and all
    additional arguments from the `fx.take` call: `np( v, ... )`.
    Return value is a new table that contains the values taken from
    the old sequence.

    If `fx.take` is called *without* a second argument, it returns a
    transducer which takes tuples during `reduce`ing. If `np` is a
    predicate, it is applied to all generated values except the
    `state` parameter in that case.

    The `fx.take` function is automatically curried with one expected
    argument. This isn't very useful unless you use the placeholder
    value `fx._`:

    ```lua
    fx.take( p )       --> returns transducer
    fx.take( p, fx._ ) --> returns partially applied `fx.take`
                       --  that awaits the `f` or `t` argument.
    ```

    The returned transducer `x` is stateful, and the internal state is
    initialized when the transducer is applied to the final reducing
    function. Returned iterators are cloneable if the input iterators
    are immutable or at least cloneable as well.


*   `fx.drop( np, f [, s [, var]] ) ==> f2, s2, var2`

    `fx.drop( np, t, ... ) ==> t2`

    `fx.drop( np ) ==> x`

    The `fx.drop` function skips a certain number of values/tuples
    from a generator or a sequence(-like object). The first parameter
    `np` may either be a positive integer, in which case this number
    of values/tuples is dropped, or a predicate, in which case
    everything is dropped until the predicate evaluates to a `false`y
    value.

    If the second argument is a function, `f`, `s`, and `var` are
    evaluated as an iterator triplet, and the resulting iterator
    ignores tuples as long as the predicate returns `true`, or the
    given number of tuples hasn't been reached. After that all tuples
    are passed through.

    Otherwise the second argument is assumed to be a sequence(-like
    object) which is indexed using consecutive integers starting from
    `1` and ending at the first `nil` value. If `np` is a predicate,
    it is called with the value from the sequence and all additional
    arguments from the `fx.drop` call: `np( v, ... )`. Return value is
    a new table that contains the elements from the old sequence
    except the ones that were skipped.

    If `fx.drop` is called *without* a second argument, it returns a
    transducer which skips tuples during `reduce`ing. If `np` is a
    predicate, it is applied to all generated values except the
    `state` parameter in that case.

    The `fx.drop` function is automatically curried with one expected
    argument. This isn't very useful unless you use the placeholder
    value `fx._`:

    ```lua
    fx.drop( p )       --> returns transducer
    fx.drop( p, fx._ ) --> returns partially applied `fx.drop`
                       --  that awaits the `f` or `t` argument.
    ```

    The returned transducer `x` is stateful, and the internal state is
    initialized when the transducer is applied to the final reducing
    function. Returned iterators are cloneable if the input iterators
    are immutable or at least cloneable as well.


*   `fx.reduce( fun, init, f [, s [, var]] ) ==> val`

    `fx.reduce( fun, init, t, ... ) ==> val`

    The `fx.reduce` function calls the given "reducing function" `fun`
    for every tuple generated by the input iterator or every value
    from the input sequence, passing an additional `state` value as
    first argument. On the first call `state` is the same as `init`,
    on subsequent calls the `state` is the (first) result of the
    previous call to the reducing function. The result of the last
    call is returned from `fx.reduce` as `val`. If the reducing
    function returns `fx._` as the second return value (after the new
    `state` value), `fx.reduce` returns immediately with the new
    `state` as `val`.

    If the third argument is a function, `f`, `s`, and `var` are
    evaluated as iterator triplet and the function `fun` is called for
    every generated tuple `var_1, ..., var_n`, passing it after the
    `state` value.

    Otherwise the third argument is assumed to be a sequence(-like
    object) which is indexed using consecutive integers starting from
    `1` and ending at the first `nil` value. The function `fun` is
    called for every value `v`: `fun( state, v, ... )`. Extra
    arguments to `fx.reduce` are passed as additional arguments to
    every reducing function call.

    `fx.reduce` can also be used to execute transducers, because a
    transducer, when called with a reducing function as argument,
    returns another reducing function.

    Example:

    ```lua
    local appending = fx.curry( 2, function( n, state, ... )
      state[ #state+1 ] = select( n, ... )
      return state
    end )
    local function double( v ) return 2*v end
    local xducer = fx.compose( fx.take( 5 ), fx.map( double ) )
    local t2 = fx.reduce( xducer( appending( 1 ) ), {}, t1 )
    ```

    This protocol of calling the transducer with the final reducing
    function right before passing it to `fx.reduce` is important for
    stateful transducers, because this is the time when the internal
    state (nothing to do with the `state` value) is initialized.

    Transducers can be composed like normal functions, but they take
    effect from left to right!

  [5]: http://lua-users.org/lists/lua-l/2013-05/msg00426.html


##                           Installation                           ##

Compile the C source file `fx.c` into a shared library (`fx.so`, or
`fx.dll` on Windows) as usual for your platform and put it somewhere
into your Lua `package.cpath`.


##                             Contact                              ##

Philipp Janda, siffiejoe(a)gmx.net

Comments and feedback are always welcome.


##                             License                              ##

**FX** is *copyrighted free software* distributed under the MIT
license (the same license as Lua 5.1). The full license text follows:

    FX (c) 2013-2016 Philipp Janda

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHOR OR COPYRIGHT HOLDER BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


